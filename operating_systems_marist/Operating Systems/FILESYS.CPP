#include "filesys.h"
//Stores a 40 byte page (card) of data to the drum for a process.
//The pagetype parameter is defined as PROGRAM - for a
//program card, INPUT - for an input data card, OUTPUT - for
//output data generated by a PD instruction, or STAT - for
//statistical information gerated by the termination service.
//The 40 bytes of data is in the parameter *page. The
//input parameter pid is the process id which is needed to
//keep a record of the data for future retrieval.
long filesystem::storepage(byte *page, pagetype t, long pid)
{
     long tracknumber;
     long rc;

     tracknumber = d.AllocateTrack();
     if(tracknumber==OUTOFTRACKS)
           return(OUTOFTRACKS);
     d.WriteTrack(tracknumber,page);

     if(p.queryprocess(pid)==FALSE)   //if process isn't on the track allocation
          p.addprocess(pid);       //list, add it now.

     switch(t) {        //update drum track allocation list
       case INPUT:
          p.addinputdata(pid,tracknumber);
          break;
       case OUTPUT:
          p.addoutputdata(pid,tracknumber);
          break;
       case PROGRAM:
          p.addprogramdata(pid,tracknumber);
          break;
       case STAT:
          p.addstatdata(pid,tracknumber);
          break;
       default:
          return(INVALIDTYPE);
       }//end switch

       return(0);
}

//Stores a page of data to the drum which has been removed from
//user memory due to it being swapped out to make room for another
//page. The parameter *page must contain the program data that
//was removed from user memory. It must be in an array of 40
//bytes(chars). The page number needs to be specified in the
//parameter pagenum, and the process id in the parameter pid.
long filesystem::storeswappage(byte *page, long pagenum, long pid)
{
     long tracknumber;
     long rc;

     tracknumber = d.AllocateTrack();
     if(tracknumber==OUTOFTRACKS)
           return(OUTOFTRACKS);
     d.WriteTrack(tracknumber,page);

     if(p.queryprocess(pid)==FALSE)   //if process isn't on the track allocation
          p.addprocess(pid);       //list, add it now.

     p.addswapdata(pid,tracknumber,pagenum);

     return(0);
}

//Takes a specified page of data that is on the drum and
//recorded as swap data on the process list, and copies
//the data to a new track on the drum and records the
//new track as output data.
long filesystem::swap2output(long pagenum, long pid)
{
     long tracknumber;
     byte data[41];

     if(p.queryprocess(pid)==FALSE)  //make sure the process exists
	     return(NOSWAPDATA);
     //see if there is swap data for this page # on the process list
     tracknumber = p.getswapdata(pid,pagenum);
	  if(tracknumber==-1)
	     return(NOSWAPDATA);

     //read the swapped track data from the drum and copy it
     //onto a new track
     d.ReadTrack(tracknumber,data);
     tracknumber = d.AllocateTrack();
     if(tracknumber==OUTOFTRACKS)
	   return(OUTOFTRACKS);
     d.WriteTrack(tracknumber,data);

     //update the process list with the new output track
     p.addoutputdata(pid,tracknumber);

     return(0);
}
//Takes a specified page of data that is on the drum and
//recorded as program data on the process list, and copies
//the data to a new track on the drum and records the
//new track as output data.
long filesystem::prog2output(long pagenum, long pid)
{
     long tracknumber;
     byte data[40];

     if(p.queryprocess(pid)==FALSE)  //make sure the process exists
	     return(NOPROGRAMDATA);

     //Get the track number of the program page if it exists
     tracknumber = p.getprogdata2(pid,pagenum);
	  if(tracknumber==-1)
	     return(NOPROGRAMDATA);

     //read the program data from the drum and copy it
     //onto a new track
     d.ReadTrack(tracknumber,data);
     tracknumber = d.AllocateTrack();
     if(tracknumber==OUTOFTRACKS)
	   return(OUTOFTRACKS);
     d.WriteTrack(tracknumber,data);

     //update the process list with the new output track
     p.addoutputdata(pid,tracknumber);

     return(0);
}

//Gets a page of data from the drum for a given process specified
//by pid. The pagetype parameter is defined as PROGRAM, for a
//program card, INPUT - for an input data card, OUTPUT - for
//output data generated by a PD instruction, or STAT - for
//statistical information gerated by the termination service.
//The 40 bytes of data will be written into the parameter *page.
//*page must be an allocated array of 41 bytes (chars). The
//input parameter pid is the process id which is needed to
//locate the correct track on the drum.
long filesystem::getpage(byte *page, pagetype t, long pid)
{
     long tracknumber;

     if(p.queryprocess(pid)==FALSE)   //if process isn't on the track allocation
	  return(NOTRACKSALLOCATED);       //list return an error.
     switch(t) {
       case INPUT:
          tracknumber = p.getinputdata(pid);
          if(tracknumber==-1)
             return(NOINPUTDATA);
          break;
       case OUTPUT:
          tracknumber = p.getoutputdata(pid);
          if(tracknumber==-1)
             return(NOOUTPUTDATA);
          break;
       case STAT:
          tracknumber = p.getstatdata(pid);
          if(tracknumber==-1)
             return(NOSTATDATA);
          break;
       default:
          return(INVALIDTYPE);
       }
       d.ReadTrack(tracknumber,page);
       d.DeallocateTrack(tracknumber);
       return(0);
}

//Gets a program page from the drum for a given process
//that had previously been swapped to the drum during
//execution, and now needs to be brought back into user memory
//because of a page fault. The page number and process id
//are needed to access the correct track on the drum.
//The data is written to the input parameter *page. *page
//must be an allocated array of 41 bytes (characters).
long filesystem::getswappage(byte *page, long pagenum, long pid)
{
     long tracknumber;

     if(p.queryprocess(pid)==FALSE)   //if process isn't on the track allocation
          return(NOTRACKSALLOCATED);       //list return an error.

     tracknumber = p.getswapdata(pid,pagenum);
          if(tracknumber==-1)
             return(NOSWAPDATA);

     d.ReadTrack(tracknumber,page);
     d.DeallocateTrack(tracknumber);
     return(0);
}

//Remove a page from the drum that was swapped to drum from memory,
//but is no longer needed because the user overwrote the page
//in virtual memory.
long filesystem::killswappage(long pagenum, long pid)
{
     long tracknumber;

     if(p.queryprocess(pid)==FALSE)   //if process isn't on the track allocation
          return(NOTRACKSALLOCATED);       //list return an error.

     tracknumber = p.getswapdata(pid,pagenum);
          if(tracknumber==-1)
             return(NOSWAPDATA);

     d.DeallocateTrack(tracknumber);
     return(0);
}

//gets a specified program card from the drum
//where it was stored after input spooling
long filesystem::getprogpage(byte *page, long cardnum, long pid)
{
     long tracknumber;

     if(p.queryprocess(pid)==FALSE)   //if process isn't on the track allocation
          return(NOTRACKSALLOCATED);       //list return an error.

     tracknumber = p.getprogdata(pid,cardnum);
          if(tracknumber==-1)
             return(NOPROGRAMDATA);

     d.ReadTrack(tracknumber,page);
     d.DeallocateTrack(tracknumber);
     return(0);
}
//indicates if a specific program card exists
//returns 1 if program card exists, 0 if not.
long filesystem::progexist(long cardnum, long pid)
{
     long tracknumber;

     if(p.queryprocess(pid)==FALSE)   //if process isn't on the track allocation
	  return(0);       //list return an error.

     tracknumber = p.getprogdata2(pid,cardnum);
	  if(tracknumber==-1)
	     return(0);

     return(1);
}
//indicates if any output cards exist for a process
//returns 1 if any output cards exist, 0 if not.
long filesystem::outputexist(long pid)
{
     long tracknumber;

     if(p.queryprocess(pid)==FALSE)   //if process isn't on the track allocation
	  return(0);       //list return an error.

     tracknumber = p.getoutputdata2(pid);
	  if(!tracknumber)
	     return(0);

     return(1);
}

//deallocates all tracks associated with the process id
//passed in as the parameter that have been allocated
//for input data, program data, swapped data,
//output data and statisical data. The process is then
//removed from the file system's list of active processes.
long filesystem::cleardrum(long pid)
{
      long tracknumber;

      //deallocate all drum tracks for the process
      while( (tracknumber=p.getinputdata(pid)) != -1)
	   d.DeallocateTrack(tracknumber);
      while( (tracknumber=p.getnextprogpage(pid)) != -1)
	   d.DeallocateTrack(tracknumber);
      while( (tracknumber=p.getoutputdata(pid)) != -1)
	   d.DeallocateTrack(tracknumber);
      while( (tracknumber=p.getstatdata(pid)) != -1)
	   d.DeallocateTrack(tracknumber);
      while( (tracknumber=p.getnextswapdata(pid)) != -1)
	   d.DeallocateTrack(tracknumber);

      p.removeprocess(pid);  //remove process from the file system
      return(0);
}
